#!/usr/bin/env python3
"""Build C++ sources generated by `py2cpp.py --multi-file`."""

from __future__ import annotations

import argparse
import subprocess
import sys
from pathlib import Path


def _runtime_cpp_sources() -> list[str]:
    """runtime/cpp の C++ 実装ファイル一覧を返す（モジュール個別列挙を避ける）。"""
    out: list[str] = []
    for p in sorted(Path("src/runtime/cpp/pytra/built_in").glob("*.cpp")):
        out.append(p.as_posix())
    for p in sorted(Path("src/runtime/cpp/pytra").rglob("*.cpp")):
        out.append(p.as_posix())
    return out


def _load_manifest(path: Path) -> dict[str, object]:
    import json

    obj = json.loads(path.read_text(encoding="utf-8"))
    if not isinstance(obj, dict):
        raise RuntimeError("manifest must be JSON object")
    return obj


def _collect_sources(manifest: dict[str, object]) -> list[str]:
    modules_obj = manifest.get("modules")
    if not isinstance(modules_obj, list):
        raise RuntimeError("manifest.modules must be list")
    out: list[str] = []
    i = 0
    while i < len(modules_obj):
        ent = modules_obj[i]
        if isinstance(ent, dict):
            src = ent.get("source")
            if isinstance(src, str) and src != "":
                out.append(src)
        i += 1
    if len(out) == 0:
        raise RuntimeError("manifest has no module sources")
    return out


def main(argv: list[str]) -> int:
    ap = argparse.ArgumentParser()
    ap.add_argument("manifest", help="Path to multi-file manifest.json")
    ap.add_argument("-o", "--output", default="a.out", help="Output executable path")
    ap.add_argument("--std", default="c++20", help="C++ language standard")
    ap.add_argument("--opt", default="-O2", help="Optimization flag")
    args = ap.parse_args(argv)

    manifest_path = Path(args.manifest)
    if not manifest_path.exists():
        print(f"error: manifest not found: {manifest_path}", file=sys.stderr)
        return 1
    manifest = _load_manifest(manifest_path)
    module_sources = _collect_sources(manifest)

    include_dir_obj = manifest.get("include_dir")
    include_dir = include_dir_obj if isinstance(include_dir_obj, str) else str(manifest_path.parent / "include")

    cmd = [
        "g++",
        f"-std={args.std}",
        args.opt,
        "-I",
        "src",
        "-I",
        "src/runtime/cpp",
        "-I",
        include_dir,
        *module_sources,
        *_runtime_cpp_sources(),
        "-o",
        args.output,
    ]
    p = subprocess.run(cmd)
    return int(p.returncode)


if __name__ == "__main__":
    raise SystemExit(main(sys.argv[1:]))
