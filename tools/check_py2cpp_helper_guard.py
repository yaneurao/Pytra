#!/usr/bin/env python3
"""Guard against new private helper methods in CppEmitter.

Policy:
- Language-agnostic helpers should be implemented in shared compiler layers
  (`src/pytra/compiler/*`) before adding to `src/py2cpp.py`.
- This guard fails when new private helper methods are added to CppEmitter
  unless the allowlist is explicitly updated.
"""

from __future__ import annotations

import argparse
import ast
import sys
from pathlib import Path


ROOT = Path(__file__).resolve().parents[1]
TARGET = ROOT / "src" / "py2cpp.py"
CPP_EMITTER_TARGET = ROOT / "src" / "hooks" / "cpp" / "emitter" / "cpp_emitter.py"
CPP_EMITTER_CLASS_NAME = "CppEmitter"
ALLOWLIST = ROOT / "tools" / "py2cpp_cpp_helper_allowlist.txt"


def _collect_toplevel_classes(source_path: Path) -> set[str]:
    tree = ast.parse(source_path.read_text(encoding="utf-8"))
    return {
        node.name
        for node in tree.body
        if isinstance(node, ast.ClassDef)
    }


def _has_class(source_path: Path, class_name: str) -> bool:
    return class_name in _collect_toplevel_classes(source_path)


def _collect_cpp_private_helpers(source_path: Path) -> list[str]:
    tree = ast.parse(source_path.read_text(encoding="utf-8"))
    for node in tree.body:
        if not isinstance(node, ast.ClassDef):
            continue
        if node.name != CPP_EMITTER_CLASS_NAME:
            continue
        names: list[str] = []
        for item in node.body:
            if isinstance(item, (ast.FunctionDef, ast.AsyncFunctionDef)):
                name = item.name
                if name.startswith("_") and not name.startswith("__"):
                    names.append(name)
        names.sort()
        return names
    raise RuntimeError(f"class {CPP_EMITTER_CLASS_NAME} not found in {source_path}")


def _read_allowlist(path: Path) -> list[str]:
    if not path.exists():
        return []
    rows = path.read_text(encoding="utf-8").splitlines()
    out: list[str] = []
    for row in rows:
        line = row.strip()
        if line == "" or line.startswith("#"):
            continue
        out.append(line)
    out.sort()
    return out


def _write_allowlist(path: Path, names: list[str]) -> None:
    header = [
        "# Auto-generated by tools/check_py2cpp_helper_guard.py",
        "# CppEmitter private helper allowlist (sorted)",
        "",
    ]
    path.write_text("\n".join(header + names) + "\n", encoding="utf-8")


def main() -> int:
    parser = argparse.ArgumentParser(description="Guard py2cpp private helper growth")
    parser.add_argument(
        "--write-allowlist",
        action="store_true",
        help="overwrite allowlist with current CppEmitter private helper set",
    )
    args = parser.parse_args()

    if _has_class(TARGET, CPP_EMITTER_CLASS_NAME):
        print("[FAIL] CppEmitter must not be implemented in src/py2cpp.py")
        print("Move implementation to src/hooks/cpp/emitter/cpp_emitter.py")
        return 1

    current = _collect_cpp_private_helpers(CPP_EMITTER_TARGET)

    if args.write_allowlist:
        _write_allowlist(ALLOWLIST, current)
        print(f"[OK] wrote allowlist: {ALLOWLIST.relative_to(ROOT)} ({len(current)} helpers)")
        return 0

    allowed = _read_allowlist(ALLOWLIST)
    if len(allowed) == 0:
        print(f"[FAIL] allowlist missing or empty: {ALLOWLIST.relative_to(ROOT)}")
        print("run: python3 tools/check_py2cpp_helper_guard.py --write-allowlist")
        return 1

    added = [name for name in current if name not in allowed]
    removed = [name for name in allowed if name not in current]

    if added:
        print("[FAIL] new CppEmitter private helper(s) detected in src/py2cpp.py:")
        for name in added:
            print(f"  - {name}")
        print("Move language-agnostic helpers to shared compiler layers first.")
        print("If this addition is truly C++-specific, update allowlist explicitly:")
        print("  python3 tools/check_py2cpp_helper_guard.py --write-allowlist")
        return 1

    print("[OK] py2cpp helper guard passed")
    print(f"  tracked helpers: {len(current)}")
    if removed:
        print(f"  note: removed helpers not in allowlist baseline ({len(removed)})")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
