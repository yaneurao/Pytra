#!/usr/bin/env python3
"""Generate a Makefile from py2cpp multi-file manifest."""

from __future__ import annotations

import argparse
import json
import sys
import re
from pathlib import Path

ROOT = Path(__file__).resolve().parents[1]
SRC_INCLUDE = ROOT / "src"
RUNTIME_INCLUDE = ROOT / "src" / "runtime" / "cpp"


_OPT_SHORT_RE = re.compile(r"^-O[0-3]$")


def _normalize_argv(argv: list[str]) -> list[str]:
    normalized: list[str] = []
    idx = 0
    while idx < len(argv):
        token = argv[idx]
        if token == "--opt":
            if idx + 1 < len(argv) and _OPT_SHORT_RE.match(argv[idx + 1]):
                normalized.append(f"--opt={argv[idx + 1]}")
                idx += 2
                continue
        if _OPT_SHORT_RE.match(token):
            normalized.append(f"--opt={token}")
            idx += 1
            continue
        normalized.append(token)
        idx += 1
    return normalized


def _parse_manifest(path: Path) -> dict[str, object]:
    try:
        obj = json.loads(path.read_text(encoding="utf-8"))
    except Exception as exc:
        raise RuntimeError(f"failed to parse manifest JSON: {path}: {exc}") from exc
    if not isinstance(obj, dict):
        raise RuntimeError("manifest must be a JSON object")
    return obj


def _collect_sources(manifest: dict[str, object], manifest_dir: Path) -> list[str]:
    modules_obj = manifest.get("modules")
    if not isinstance(modules_obj, list):
        raise RuntimeError("manifest.modules must be list")

    sources: list[str] = []
    for idx, ent in enumerate(modules_obj):
        if not isinstance(ent, dict):
            continue
        source = ent.get("source")
        if isinstance(source, str) and source != "":
            src_path = Path(source)
            if not src_path.is_absolute():
                src_path = manifest_dir / src_path
            if not src_path.exists():
                raise RuntimeError(f"manifest module source not found at index={idx}: {source}")
            sources.append(str(src_path))
            continue
        raise RuntimeError(f"manifest module[{idx}] missing source")

    if len(sources) == 0:
        raise RuntimeError("manifest has no valid module sources")
    return sources


def _collect_runtime_sources() -> list[str]:
    runtime_root = ROOT / "src" / "runtime" / "cpp" / "pytra"
    if not runtime_root.exists():
        raise RuntimeError(f"runtime source root not found: {runtime_root}")
    return sorted(str(p) for p in runtime_root.rglob("*.cpp"))


def _as_makefile_path(manifest_path: Path, output: str) -> Path:
    if output == "":
        return manifest_path.parent / "Makefile"
    return Path(output)


def _build_makefile_text(
    makefile_path: Path,
    exe: str,
    compiler: str,
    std: str,
    opt: str,
    include_dir: str,
    sources: list[str],
) -> str:
    obj_dir = makefile_path.parent / ".obj"
    objects: list[str] = []
    compile_rules: list[str] = []
    idx = 0
    while idx < len(sources):
        src = sources[idx]
        stem = Path(src).stem
        obj = obj_dir / f"{idx:03d}_{stem}.o"
        objects.append(str(obj))
        compile_rules.extend(
            [
                f"{obj}: {src} | $(OBJDIR)",
                "\t$(CXX) $(CXXFLAGS) $(INCLUDES) -c $< -o $@",
                "",
            ]
        )
        idx += 1

    include_arg = f"-I{include_dir}"
    lines: list[str] = [
        "# Auto-generated by tools/gen_makefile_from_manifest.py",
        f"# output: {makefile_path}",
        "",
        f"CXX := {compiler}",
        f"CXXFLAGS := -std={std} {opt}",
        f"INCLUDES := -I{SRC_INCLUDE} -I{RUNTIME_INCLUDE} {include_arg}",
        f"OBJS := {' '.join(objects)}",
        f"TARGET := {exe}",
        f"OBJDIR := {obj_dir}",
        "",
        ".PHONY: all run clean",
        "",
        "all: $(TARGET)",
        "",
        "$(TARGET): $(OBJS)",
        "\t$(CXX) $(CXXFLAGS) $(INCLUDES) $(OBJS) -o $(TARGET)",
        "",
        "$(OBJDIR):",
        "\tmkdir -p $(OBJDIR)",
        "",
    ]
    lines.extend(compile_rules)
    lines.extend(
        [
            "run:",
            "\t./$(TARGET)",
            "",
            "clean:",
            "\t$(RM) $(OBJS) $(TARGET)",
            "",
        ]
    )
    return "\n".join(lines)


def main(argv: list[str]) -> int:
    argv = _normalize_argv(list(argv))

    ap = argparse.ArgumentParser(
        description="Generate Makefile from py2cpp multi-file manifest.json."
    )
    ap.add_argument("manifest", help="Path to multi-file manifest.json")
    ap.add_argument("-o", "--output", default="Makefile", help="Output Makefile path")
    ap.add_argument("--exe", default="app.out", help="Executable target name")
    ap.add_argument("--compiler", default="g++", help="C++ compiler")
    ap.add_argument("--std", default="c++20", help="C++ language standard")
    ap.add_argument("--opt", default="-O2", help="C++ compiler optimization flag")

    args = ap.parse_args(argv)

    manifest_path = Path(args.manifest)
    if not manifest_path.exists():
        print(f"error: manifest not found: {manifest_path}", file=sys.stderr)
        return 1

    makefile_path = _as_makefile_path(manifest_path, args.output)

    try:
        manifest = _parse_manifest(manifest_path)
        include_dir = manifest.get("include_dir")
        include_dir_txt = (
            str(manifest_path.parent / "include")
            if not isinstance(include_dir, str)
            else str(manifest_path.parent / include_dir)
            if not Path(include_dir).is_absolute()
            else include_dir
        )
        sources = _collect_sources(manifest, manifest_path.parent)
        sources.extend(_collect_runtime_sources())
        text = _build_makefile_text(
            makefile_path,
            exe=args.exe,
            compiler=args.compiler,
            std=args.std,
            opt=args.opt,
            include_dir=include_dir_txt,
            sources=sources,
        )
        makefile_path.parent.mkdir(parents=True, exist_ok=True)
        makefile_path.write_text(text + "\n", encoding="utf-8")
    except Exception as exc:
        print(f"error: {exc}", file=sys.stderr)
        return 1

    print(f"generated: {makefile_path}")
    return 0


if __name__ == "__main__":
    raise SystemExit(main(sys.argv[1:]))
