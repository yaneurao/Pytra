# C++ List Reference Semantics Specification (pyobj default)

This document defines, for `list` in the C++ backend, the current contract (`pyobj` default) and rollback compatibility (`value`).

## 1. Purpose

- Make `list` semantics explicit in terms of what is guaranteed now and what is not yet guaranteed.
- Fix the regression-judgment baseline during staged migration of `P1-LIST-PYOBJ-MIG-01`.
- Clarify boundary conditions between default `pyobj` operation and rollback (`--cpp-list-model value`).

## 2. Scope

- In scope: `list[...]` generated by the C++ runtime / C++ emitter.
- Out of scope: Reference-model migration for `dict` / `set` / `str` (separate tasks).

## 3. Terms

- `value model`: Current model where `list<T>` is held and assigned as a value.
- `pyobj model`: Reference model where `list` itself is held as `PyObj`-derived + `rc<>`.
- `alias`: Sharing the same list, such as `b = a`.

## 4. Current Operation (as of 2026-02-28)

- Default `list` model in `py2cpp` is `pyobj`.
- Specify `--cpp-list-model value` only when rollback is required.
- Under default `pyobj`, `list` is handled as `object` (`PyListObj`).

## 5. Compatibility Contract (`value model`: rollback only)

- `list<T>` is treated as a value type, and `b = a` produces a copy.
- `append/pop/extend` perform destructive updates on the received list value.
- Boxing to `PyListObj(list<object>)` happens only at `Any/object` boundaries.
- Therefore, static-type paths can diverge from Python alias sharing.

## 6. Target Contract (`pyobj model`)

- `list` is shared by reference by default, and `append/pop` after `b = a` are mutually observable.
- Preserve sharing of the same list for function arguments, return values, and attribute storage.
- For boxing/unboxing at `Any/object` boundaries, prioritize no-op compatibility (preserve identical entity).

## 7. Contract for Destructive Updates

- `append/pop/extend/clear` operate in place on the list entity.
- If shared aliases exist, update results must be observable from all references.
- Updates are independent only for non-aliases (different entities).

## 8. `PyListObj` Lifetime / Iterator Contract

- `PyListObj::py_iter_or_raise()` returns an iterator that references the owner list entity, not a snapshot of list values.
- The iterator retains the owner list lifetime (stops when owner reference becomes invalid).
- Elements appended via `py_append` during iteration are reflected in iteration results as long as they are in an unscanned range.
- `py_try_len` / `py_truthy` are evaluated against the current state of the owner list entity.

## 9. Staged Migration Policy

- Phase 1: Allow the dual model (`value|pyobj`) and enable comparison with a switch flag.
- Phase 2: Stabilize transpile/smoke/parity on the `pyobj` model.
- Phase 3: Shrink only non-escape-annotated paths to stack/RAII.
- Phase 4: Default has already switched to `pyobj`. Keep `value` only during rollback period; remove it in stages under a separate ID.

## 10. Fail-Closed Rules

- Do not apply optimization to unconvertible paths, unknown types, or mixed external-call paths.
- Do not stack-allocate lists whose non-escape cannot be proven.
- If semantics are unclear, fall back to heap/pyobj side.

## 11. Acceptance Criteria

- Match Python on alias-expected fixtures (`append/pop` after `a=b`).
- Pass `check_py2cpp_transpile` / C++ smoke / sample parity.
- While diffs remain, pin `case name` and `diff detail` in the decision log of the plan document.
