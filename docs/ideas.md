# アイデア

いま、Pythonから様々な言語へのトランスパイラを作成しているところである。
しかし、元のコード(Python側)である程度、型注釈を省略して書きたい。そのためには型推論が必要になるが、Pythonのastモジュールはそこまでやってくれない。
また、現状、main()の名前が変換先の言語で衝突するからとrenameしたりしているが、それを各言語用のトランスパイラが個別にするはおかしい話である。
あと、関数のなかで引数をreadonlyでしか使っていないならば、(C++で言う)const& で渡せるはずである。しかしastモジュールではそこまでわからない。これを、各言語用のトランスパイラが判定するのはおかしい設計である。

そこで、astモジュールのAST(抽象構文木)を拡張した、EAST(extended AST)を考える。

EASTでは、これらの問題が解決している。

トランスパイラは、まずPythonのコードを EASTモジュールを用いてeastに変換する。
各言語用のトランスパイラは、eastに基づき、何も考えずに各言語用の出力を作れば良いのである。


EASTは、
- 完全な中間表現を目指す(型注釈あり、拡張された型注釈あり)
- 人間が読むソースコードに変換しやすい形(変数名はなるべく元のまま、元ソースコードのコメントはなるべくそのまま残す)
- 型推論は、積極推論。ただし、誤推論は許せないので、型推論に失敗した場合、トランスパイルのエラーになって良い。
- Rustの&/&mutも型注釈として書かれているようにする。
- 型castが必要な部分は明示的に記述する。
を目指す。

## EAST仕様（草案）

### 1. 目的

- 目的1: 各言語トランスパイラに分散している前処理（型推論、名前衝突回避、読み取り専用解析）を共通化する。
- 目的2: 言語別バックエンドは「EASTを各言語へloweringする責務」に集中させる。
- 目的3: 推論結果を明示データとして保持し、誤推論ではなく「変換エラー」で止める。

### 2. スコープ

- 対象: 現在 Pytra が対応している Python サブセット。
- 非対象: Python 完全互換（動的 import、完全な実行時メタプログラミングなど）。

### 3. EASTの責務境界

- 責務A（構文正規化）:
  - `if __name__ == "__main__":` の抽出
  - `main` などエントリポイント名衝突の解消（共通規則でrename）
  - 必要な一時変数導入（多重代入展開など）
- 責務B（意味注釈）:
  - 変数/引数/戻り値の型注釈（推論含む）
  - 参照特性注釈（readonly / mutable / move）
  - 必要castの明示挿入
- 責務C（バックエンド受け渡し）:
  - 各ノードが「型」「cast要否」「参照特性」を持つことを保証する
  - バックエンドはこの情報を使って出力を作る

注意:
- 言語固有の最終判断（例: Rust所有権細部、Java null扱い、C++寿命最適化）はバックエンドに残す。
- EASTは「全てを消す層」ではなく「共通化できる最大範囲を担う層」とする。

### 4. EASTノード要件

各式ノード・代入ノードは最低限以下を持つ:

- `resolved_type`: 解決済み型（例: `int`, `float`, `str`, `list[int]`, `Path` など）
- `borrow_kind`: `value` / `readonly_ref` / `mutable_ref` / `move`
- `casts`: 必要な暗黙変換を明示したcast情報
- `source_span`: 元ソース位置（行・列）

各関数ノードは以下を持つ:

- `arg_types`, `return_type`
- `arg_usage`: 引数ごとの `readonly` / `mutable`
- `renamed_symbols`: 衝突回避でrenameした識別子情報

### 5. 型システム（EAST内）

- 基本型:
  - `int`, `float`, `bool`, `str`, `bytes`, `bytearray`, `None`
- 合成型:
  - `list[T]`, `dict[K,V]`, `set[T]`, `tuple[T1,...]`
- 拡張型:
  - `Path`
  - 将来拡張用のユーザー定義クラス型

補足:
- EAST内の型は「Python表記ベース」で保持し、各言語型への対応表はバックエンド側で持つ。

### 6. 型推論ルール

- 方針: 積極推論。ただし健全性優先。
- 推論成功条件:
  - 一意に型が決まること
  - 以後の使用点で矛盾しないこと
- 推論失敗条件:
  - 複数候補が残る
  - 推論結果が使用点で矛盾する
- 失敗時挙動:
  - EAST生成を中断し、エラーを返す
  - エラーには `source_span` と「不足注釈候補」を含める

### 7. readonly解析と参照注釈

- 関数引数について、以下で `readonly` 判定:
  - 再代入されない
  - 可変操作（`append`, `setitem`, フィールド更新）をしない
  - 可変参照として他関数へ渡さない
- 判定結果を `arg_usage` に保存し、バックエンドで利用:
  - C++: `const&` 候補
  - Rust: `&T` 候補

### 8. cast規則

- 数値混在やバイト列操作などで必要な変換はEAST上で明示castノードを付与する。
- バックエンドは原則「cast指示をそのまま出力」する。
- バックエンド独自cast追加は可。ただしEASTのcastと矛盾してはならない。

### 9. エラー契約

- EAST生成エラーは必ず次を返す:
  - エラー種別（推論失敗 / 未対応構文 / 矛盾）
  - ソース位置
  - 短い修正指針（例: 「この変数に型注釈を追加してください」）

### 10. バックエンド契約

- 入力はEASTのみを受ける（Python AST直読みは段階的に廃止）。
- バックエンドの責務:
  - EAST型を対象言語型へ写像
  - 言語固有のメモリ/例外/標準ライブラリ差分を吸収
  - EASTのcast/borrow注釈を尊重

### 11. 段階導入計画

- Phase 1:
  - EAST生成器を実装（型解決 + rename + cast）
  - 既存バックエンドはAST/EAST両対応のブリッジで動かす
- Phase 2:
  - C++/Rust/Go/JavaからEAST専用経路へ移行
- Phase 3:
  - C#/JS/TS/Swift/Kotlinへ展開
  - AST直読み経路を削除

### 12. 受け入れ基準

- `test/fixtures/py` の既存ケースがEAST経由で全て変換可能
- 既存出力との差分が許容範囲内（仕様差分は文書化）
- 推論失敗時のエラーメッセージに位置と対処が含まれる
- `math/pathlib` など共通ランタイムケースで言語間一致が維持される

## 仕様化

- 上記草案を MUST/SHOULD 形式へ整理した仕様: `docs/spec-east.md`
