# 開発思想

<a href="../docs-en/philosophy.md">
  <img alt="Read in English" src="https://img.shields.io/badge/docs-English-2563EB?style=flat-square">
</a>


Pytra は、「1つのロジックを複数言語で無理なく運用する」ことを目的にしたトランスパイラです。

マルチプラットフォーム開発では、用途ごとに採用言語が分かれるのが一般的です。  
このとき同じ仕様を複数言語で再実装・再保守すると、コストだけでなく仕様差分やバグ混入のリスクが増えます。  
Pytra は、この重複を減らすために「コアロジックを Python で書き、必要な言語へ変換する」という方針を取ります。

## なぜ Python AST だけでは不十分か

Python 標準の `ast` は構文木として有用ですが、実運用向けトランスパイルでは情報が不足します。
主な不足点は次の通りです。

- コメント・空行・元のレイアウト情報を保持しないため、変換後コードを「元コードに近い形」で再現しにくい。
- 型注釈が省略された箇所の推論結果や、必要な cast 情報を標準 AST 自体は保持しない。
- `range` 正規化、名前衝突回避、main ガード抽出などの前処理を各バックエンドに重複実装しやすい。
- 引数の読み取り専用性（readonly/mutable）など、最適化に効く意味情報を共通データとして渡しにくい。

これらを各言語バックエンドで個別に補うと、前処理実装が分散し、挙動差分と保守コストが増えます。  
Pytra はこの問題を避けるため、AST の後段で共通の意味付けを確定する層を導入しています。

## EAST中心設計

EAST（Extended AST）は、このPytraのために設計した拡張抽象構文木です。  
既存の一般規格を採用したものではなく、上記の不足を補うために定義しています。

EAST は Python AST を置き換えるものではなく、AST の後段で意味情報を補完する層です。

- 共通化: 型推論、cast 明示、`range` 正規化、名前衝突回避などを EAST 構築段階で確定する。
- 責務分離: バックエンド（C++ など）は「EAST を対象言語へ写像する責務」に集中する。
- 安全性: 推論が一意に確定しない場合は曖昧に生成せず、エラーとして停止する。
- 保守性: 変換後コードは元ソースの意図（名前・コメント・空行・構造）をなるべく維持する。

この方針により、言語ごとの差分実装を減らし、仕様整合と性能改善を同時に進めます。

EAST の実装準拠仕様は [EAST仕様（実装準拠）](spec-east.md) を参照してください。

## 重視していること

- 可読性: 変換後コードが読めることを重視し、変数名・コメント・空行・構造をなるべく維持する。
- 性能: Python 実装を C++/Rust などへ変換し、実運用で使える速度に近づける。
- 検証容易性: Python 実行結果と変換先実行結果を比較しやすい構成を優先する。
- 拡張性: EAST を介して、段階的に対応構文・最適化・対応言語を増やせるようにする。

## 性能に対する姿勢

Pytra は「Pythonで書いたら遅いまま」ではなく、必要に応じてネイティブ実行系へ寄せることを狙っています。  
最終的には、C++ で手書きした実装に近い性能を出せる変換品質を目標にしています。

ただし、速度だけを優先して可読性や追跡可能性を失う設計は避けます。  
運用・保守・デバッグを継続できることを前提に、段階的に最適化を進めます。

## 開発・運用の基本方針

- まず正しく動くことを優先し、その後に最適化を適用する。
- 変換ルールはできるだけ明示し、挙動の再現性を高める。
- selfhost（トランスパイラ自身の変換）を通じて、設計の弱点を継続的に洗い出す。

この思想により、Pytra は単なるコード生成器ではなく、複数言語運用における実務的な土台を目指します。
