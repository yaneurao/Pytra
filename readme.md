# Pytraã¨ã¯ä½•ï¼Ÿ

Pytraã¯ã€Pythonã®ã‚µãƒ–ã‚»ãƒƒãƒˆã§æ›¸ã‹ã‚ŒãŸãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’æ§˜ã€…ãªè¨€èªã«å¤‰æ›ã™ã‚‹ãŸã‚ã®ãƒˆãƒ©ãƒ³ã‚¹ãƒ‘ã‚¤ãƒ©ç¾¤ã§ã™ã€‚

ç¾åœ¨ã¯ Python ã‹ã‚‰ C++/C#/Rust ã¸ã®å¤‰æ›ã«å¯¾å¿œã—ã¦ãŠã‚Šã€JavaScript/TypeScript/Go/Java/Swift/Kotlin ã¯å¯¾å¿œäºˆå®šã§ã™ã€‚

âš  ã¾ã é–‹ç™ºé€”ä¸Šã«ã‚ã‚Šã€å®Ÿç”¨ã«ã»ã©é ã„ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚ã‚µãƒ³ãƒ—ãƒ«ã‚³ãƒ¼ãƒ‰ãªã©ã‚’ç¢ºèªã—ã¦ã‹ã‚‰è‡ªå·±è²¬ä»»ã«ãŠã„ã¦ã€ã”åˆ©ç”¨ãã ã•ã„ã€‚

âš  Pythonã§æ›¸ã„ãŸãƒ—ãƒ­ã‚°ãƒ©ãƒ ä¸¸ã”ã¨ã‚’ç§»æ¤ã§ãã‚‹ã“ã¨ã¯æœŸå¾…ã—ãªã„ã§ãã ã•ã„ã€‚ã€ŒPythonã§æ›¸ã„ãŸã‚³ã‚¢ã‚³ãƒ¼ãƒ‰ãŒä¸Šæ‰‹ãå¤‰æ›ã•ã‚ŒãŸã‚‰ãƒ©ãƒƒã‚­ãƒ¼ã ãªã€ãã‚‰ã„ã®æ¸©åº¦æ„Ÿã§ãŠä½¿ã„ãã ã•ã„ã€‚

## é–‹ç™ºå‹•æ©Ÿ

ãƒãƒ«ãƒãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ å¯¾å¿œã®ã‚²ãƒ¼ãƒ ã‚’ä½œã‚ã†ã¨æ€ã†ã¨ã€ç¾åœ¨ã¯ã€UnityãŒç¾å®Ÿè§£ã§ã™ã€‚Unityã§ã¯C#ã§æ›¸ãå¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚ç§ã¯ã‚µãƒ¼ãƒãƒ¼ã‚µã‚¤ãƒ‰ã¯ã€Pythonã§æ›¸ããŸã‹ã£ãŸã®ã§ã™ãŒã€ãƒ–ãƒ©ã‚¦ã‚¶å´ã‚‚ã‚ã‚‹ãªã‚‰ã€ãã“ã¯JavaScriptã§æ›¸ãå¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚

ã“ã†ãªã‚‹ã¨3ã¤ã®è¨€èªã‚’è¡Œãæ¥ã—ã¦ã€åŒã˜ãƒ­ã‚¸ãƒƒã‚¯ã‚’3å›å®Ÿè£…ã—ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ã€Œã“ã‚Œã¯ã•ã™ãŒã«ãŠã‹ã—ã„ã®ã§ã¯ï¼Ÿã€ã¨æ€ã£ãŸã®ãŒæœ¬ãƒˆãƒ©ãƒ³ã‚¹ãƒ‘ã‚¤ãƒ©ã®é–‹ç™ºã®ãã£ã‹ã‘ã§ã™ã€‚

ã¾ãŸã€ç´ ã®Pythonã ã¨é…ã™ãã¦ã‚µãƒ¼ãƒãƒ¼ã‚µã‚¤ãƒ‰ã§å¤§é‡ã®ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’æŒãã®ã«ã¯å‘ã‹ãªã„ã§ã™ã€‚ã“ã“ãŒå°‘ã—ã§ã‚‚é€Ÿããªã‚Œã°ã¨æ€ã„ã€é–‹ç™ºã—ã¾ã—ãŸã€‚

JavaScriptã®ã‚³ãƒ¼ãƒ‰ã«ã‚‚å¤‰æ›ã§ãã‚‹ã®ã§ã€Pythonã§ãƒ–ãƒ©ã‚¦ã‚¶ã‚²ãƒ¼ãƒ ã®é–‹ç™ºã‚‚ã§ãã¾ã™ã€‚


## å®Ÿè¡Œé€Ÿåº¦ã®æ¯”è¼ƒ

ã‚µãƒ³ãƒ—ãƒ«ã‚³ãƒ¼ãƒ‰(Pythonã§æ›¸ã‹ã‚Œã¦ã„ã‚‹)ã®å®Ÿè¡Œæ™‚é–“ã¨ã€ãã®ãƒˆãƒ©ãƒ³ã‚¹ãƒ‘ã‚¤ãƒ«ã—ãŸã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ã§ã®å®Ÿè¡Œæ™‚é–“ã€‚ï¼ˆå˜ä½: ç§’ï¼‰

ğŸ’¡ å…ƒã®ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ã€å¤‰æ›ã•ã‚ŒãŸã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ã€è¨ˆæ¸¬æ¡ä»¶ç­‰ã«ã¤ã„ã¦ã¯ã€[docs/time-comparison.md](docs/time-comparison.md) ã‚’ã”è¦§ãã ã•ã„ã€‚

|ãƒ•ã‚¡ã‚¤ãƒ«å|å†…å®¹|Python| C++ | C# | Rust | JS | TypeScript |
|-|-|-:|-:|-:|-|-|-|
|01_mandelbrot|ãƒãƒ³ãƒ‡ãƒ«ãƒ–ãƒ­é›†åˆï¼ˆPNGï¼‰|1.689|0.089|0.078|0.124|ğŸš§|ğŸš§|
|02_raytrace_spheres|çƒã®ç°¡æ˜“ãƒ¬ã‚¤ãƒˆãƒ¬ãƒ¼ã‚µï¼ˆPNGï¼‰|0.414|0.030|0.121|0.054|ğŸš§|ğŸš§|
|03_julia_set|ã‚¸ãƒ¥ãƒªã‚¢é›†åˆï¼ˆPNGï¼‰|1.380|0.087|0.141|0.110|ğŸš§|ğŸš§|
|04_monte_carlo_pi|ãƒ¢ãƒ³ãƒ†ã‚«ãƒ«ãƒ­æ³•ã§å††å‘¨ç‡è¿‘ä¼¼|3.657|0.052|0.200|0.066|ğŸš§|ğŸš§|
|05_mandelbrot_zoom|ãƒãƒ³ãƒ‡ãƒ«ãƒ–ãƒ­ã‚ºãƒ¼ãƒ ï¼ˆGIFï¼‰|13.802|0.525|2.694|0.529|ğŸš§|ğŸš§|
|06_julia_parameter_sweep|ã‚¸ãƒ¥ãƒªã‚¢é›†åˆãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿æƒå¼•ï¼ˆGIFï¼‰|9.825|0.383|1.929|0.385|ğŸš§|ğŸš§|
|07_game_of_life_loop|ãƒ©ã‚¤ãƒ•ã‚²ãƒ¼ãƒ ï¼ˆGIFï¼‰|1.290|0.067|0.314|0.109|ğŸš§|ğŸš§|
|08_langtons_ant|ãƒ©ãƒ³ã‚°ãƒˆãƒ³ã®ã‚¢ãƒªï¼ˆGIFï¼‰|0.744|0.050|0.234|0.145|ğŸš§|ğŸš§|
|09_fire_simulation|ç‚ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ï¼ˆGIFï¼‰|1.088|0.054|0.522|0.435|ğŸš§|ğŸš§|
|10_plasma_effect|ãƒ—ãƒ©ã‚ºãƒã‚¨ãƒ•ã‚§ã‚¯ãƒˆï¼ˆGIFï¼‰|2.419|0.221|0.769|0.184|ğŸš§|ğŸš§|
|11_lissajous_particles|ãƒªã‚µãƒ¼ã‚¸ãƒ¥ç²’å­ï¼ˆGIFï¼‰|1.118|0.081|0.163|0.076|ğŸš§|ğŸš§|
|12_sort_visualizer|ã‚½ãƒ¼ãƒˆå¯è¦–åŒ–ï¼ˆGIFï¼‰|3.471|0.233|0.465|0.220|ğŸš§|ğŸš§|
|13_maze_generation_steps|è¿·è·¯ç”Ÿæˆã‚¹ãƒ†ãƒƒãƒ—ï¼ˆGIFï¼‰|0.521|0.033|0.113|0.037|ğŸš§|ğŸš§|
|14_raymarching_light_cycle|ç°¡æ˜“ãƒ¬ã‚¤ãƒãƒ¼ãƒãƒ³ã‚°ï¼ˆGIFï¼‰|2.666|0.152|0.467|0.152|ğŸš§|ğŸš§|
|15_mini_language_interpreter|ãƒŸãƒ‹è¨€èªã‚¤ãƒ³ã‚¿ãƒ—ãƒªã‚¿ |2.207|0.577|1.035|ğŸš§|ğŸš§|ğŸš§|

![06_julia_parameter_sweep](images/06_julia_parameter_sweep.gif)

<details>
<summary>ã‚µãƒ³ãƒ—ãƒ«ã‚³ãƒ¼ãƒ‰ : 06_julia_parameter_sweep.py</summary>

```python
# 06: ã‚¸ãƒ¥ãƒªã‚¢é›†åˆã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’å›ã—ã¦GIFå‡ºåŠ›ã™ã‚‹ã‚µãƒ³ãƒ—ãƒ«ã€‚

from __future__ import annotations

import math
from time import perf_counter

from py_module.gif_helper import save_gif


def julia_palette() -> bytes:
    # å…ˆé ­è‰²ã¯é›†åˆå†…éƒ¨ç”¨ã«é»’å›ºå®šã€æ®‹ã‚Šã¯é«˜å½©åº¦ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’ä½œã‚‹ã€‚
    palette = bytearray(256 * 3)
    palette[0] = 0
    palette[1] = 0
    palette[2] = 0
    for i in range(1, 256):
        t = (i - 1) / 254.0
        r = int(255.0 * (9.0 * (1.0 - t) * t * t * t))
        g = int(255.0 * (15.0 * (1.0 - t) * (1.0 - t) * t * t))
        b = int(255.0 * (8.5 * (1.0 - t) * (1.0 - t) * (1.0 - t) * t))
        palette[i * 3 + 0] = r
        palette[i * 3 + 1] = g
        palette[i * 3 + 2] = b
    return bytes(palette)


def render_frame(width: int, height: int, cr: float, ci: float, max_iter: int, phase: int) -> bytes:
    frame = bytearray(width * height)
    idx = 0
    for y in range(height):
        zy0 = -1.2 + 2.4 * (y / (height - 1))
        for x in range(width):
            zx = -1.8 + 3.6 * (x / (width - 1))
            zy = zy0
            i = 0
            while i < max_iter:
                zx2 = zx * zx
                zy2 = zy * zy
                if zx2 + zy2 > 4.0:
                    break
                zy = 2.0 * zx * zy + ci
                zx = zx2 - zy2 + cr
                i += 1
            if i >= max_iter:
                frame[idx] = 0
            else:
                # ãƒ•ãƒ¬ãƒ¼ãƒ ä½ç›¸ã‚’å°‘ã—åŠ ãˆã¦è‰²ãŒæ»‘ã‚‰ã‹ã«æµã‚Œã‚‹ã‚ˆã†ã«ã™ã‚‹ã€‚
                color_index = 1 + (((i * 224) // max_iter + phase) % 255)
                frame[idx] = color_index
            idx += 1
    return bytes(frame)


def run_06_julia_parameter_sweep() -> None:
    width = 320
    height = 240
    frames_n = 72
    max_iter = 180
    out_path = "sample/out/06_julia_parameter_sweep.gif"

    start = perf_counter()
    frames: list[bytes] = []
    # æ—¢çŸ¥ã®è¦‹æ „ãˆãŒè‰¯ã„è¿‘å‚ã‚’æ¥•å††è»Œé“ã§å·¡å›ã—ã€å˜èª¿ãªç™½é£›ã³ã‚’æŠ‘ãˆã‚‹ã€‚
    center_cr = -0.745
    center_ci = 0.186
    radius_cr = 0.12
    radius_ci = 0.10
    for i in range(frames_n):
        t = i / frames_n
        angle = 2.0 * math.pi * t
        cr = center_cr + radius_cr * math.cos(angle)
        ci = center_ci + radius_ci * math.sin(angle)
        phase = (i * 5) % 255
        frames.append(render_frame(width, height, cr, ci, max_iter, phase))

    save_gif(out_path, width, height, frames, julia_palette(), delay_cs=8, loop=0)
    elapsed = perf_counter() - start
    print("output:", out_path)
    print("frames:", frames_n)
    print("elapsed_sec:", elapsed)


if __name__ == "__main__":
    run_06_julia_parameter_sweep()
```
</details>

<details>
<summary>C++ã¸ã®å¤‰æ›ä¾‹ : 06_julia_parameter_sweep.cpp</summary>

```cpp
#include "cpp_module/gc.h"
#include "cpp_module/gif.h"
#include "cpp_module/math.h"
#include "cpp_module/py_runtime.h"
#include "cpp_module/time.h"
#include <algorithm>
#include <any>
#include <cstdint>
#include <fstream>
#include <ios>
#include <iostream>
#include <sstream>
#include <stdexcept>
#include <string>
#include <tuple>
#include <type_traits>
#include <unordered_map>
#include <unordered_set>
#include <vector>

using namespace std;
using namespace pycs::gc;

string julia_palette()
{
    string palette = py_bytearray((256 * 3));
    palette[0] = 0;
    palette[1] = 0;
    palette[2] = 0;
    auto __pytra_range_start_1 = 1;
    auto __pytra_range_stop_2 = 256;
    auto __pytra_range_step_3 = 1;
    if (__pytra_range_step_3 == 0) throw std::runtime_error("range() arg 3 must not be zero");
    for (auto i = __pytra_range_start_1; (__pytra_range_step_3 > 0) ? (i < __pytra_range_stop_2) : (i > __pytra_range_stop_2); i += __pytra_range_step_3)
    {
        double t = py_div((i - 1), 254.0);
        long long r = static_cast<long long>((255.0 * ((((9.0 * (1.0 - t)) * t) * t) * t)));
        long long g = static_cast<long long>((255.0 * ((((15.0 * (1.0 - t)) * (1.0 - t)) * t) * t)));
        long long b = static_cast<long long>((255.0 * ((((8.5 * (1.0 - t)) * (1.0 - t)) * (1.0 - t)) * t)));
        palette[((i * 3) + 0)] = r;
        palette[((i * 3) + 1)] = g;
        palette[((i * 3) + 2)] = b;
    }
    return py_bytes(palette);
}

string render_frame(long long width, long long height, double cr, double ci, long long max_iter, long long phase)
{
    string frame = py_bytearray((width * height));
    long long idx = 0;
    auto __pytra_range_start_4 = 0;
    auto __pytra_range_stop_5 = height;
    auto __pytra_range_step_6 = 1;
    if (__pytra_range_step_6 == 0) throw std::runtime_error("range() arg 3 must not be zero");
    for (auto y = __pytra_range_start_4; (__pytra_range_step_6 > 0) ? (y < __pytra_range_stop_5) : (y > __pytra_range_stop_5); y += __pytra_range_step_6)
    {
        double zy0 = ((-1.2) + (2.4 * py_div(y, (height - 1))));
        auto __pytra_range_start_7 = 0;
        auto __pytra_range_stop_8 = width;
        auto __pytra_range_step_9 = 1;
        if (__pytra_range_step_9 == 0) throw std::runtime_error("range() arg 3 must not be zero");
        for (auto x = __pytra_range_start_7; (__pytra_range_step_9 > 0) ? (x < __pytra_range_stop_8) : (x > __pytra_range_stop_8); x += __pytra_range_step_9)
        {
            double zx = ((-1.8) + (3.6 * py_div(x, (width - 1))));
            auto zy = zy0;
            long long i = 0;
            while ((i < max_iter))
            {
                auto zx2 = (zx * zx);
                auto zy2 = (zy * zy);
                if (((zx2 + zy2) > 4.0))
                {
                    break;
                }
                zy = (((2.0 * zx) * zy) + ci);
                zx = ((zx2 - zy2) + cr);
                i = (i + 1);
            }
            if ((i >= max_iter))
            {
                frame[idx] = 0;
            }
            else
            {
                long long color_index = (1 + ((py_floordiv((i * 224), max_iter) + phase) % 255));
                frame[idx] = color_index;
            }
            idx = (idx + 1);
        }
    }
    return py_bytes(frame);
}

void run_06_julia_parameter_sweep()
{
    long long width = 320;
    long long height = 240;
    long long frames_n = 72;
    long long max_iter = 180;
    string out_path = "sample/out/06_julia_parameter_sweep.gif";
    auto start = perf_counter();
    vector<string> frames = {};
    double center_cr = (-0.745);
    double center_ci = 0.186;
    double radius_cr = 0.12;
    double radius_ci = 0.1;
    auto __pytra_range_start_10 = 0;
    auto __pytra_range_stop_11 = frames_n;
    auto __pytra_range_step_12 = 1;
    if (__pytra_range_step_12 == 0) throw std::runtime_error("range() arg 3 must not be zero");
    for (auto i = __pytra_range_start_10; (__pytra_range_step_12 > 0) ? (i < __pytra_range_stop_11) : (i > __pytra_range_stop_11); i += __pytra_range_step_12)
    {
        double t = py_div(i, frames_n);
        double angle = ((2.0 * pycs::cpp_module::math::pi) * t);
        auto cr = (center_cr + (radius_cr * pycs::cpp_module::math::cos(angle)));
        auto ci = (center_ci + (radius_ci * pycs::cpp_module::math::sin(angle)));
        long long phase = ((i * 5) % 255);
        frames.push_back(render_frame(width, height, cr, ci, max_iter, phase));
    }
    pycs::cpp_module::gif::save_gif(out_path, width, height, frames, julia_palette(), 8, 0);
    auto elapsed = (perf_counter() - start);
    py_print("output:", out_path);
    py_print("frames:", frames_n);
    py_print("elapsed_sec:", elapsed);
}

int main()
{
    run_06_julia_parameter_sweep();
    return 0;
}
```
</details>

<details>
<summary>C#ã¸ã®å¤‰æ›ä¾‹ : 06_julia_parameter_sweep.cs</summary>

```csharp
using System.Collections.Generic;
using System.IO;
using System;

public static class Program
{
    public static List<byte> julia_palette()
    {
        var palette = Pytra.CsModule.py_runtime.py_bytearray((256L * 3L));
        Pytra.CsModule.py_runtime.py_set(palette, 0L, 0L);
        Pytra.CsModule.py_runtime.py_set(palette, 1L, 0L);
        Pytra.CsModule.py_runtime.py_set(palette, 2L, 0L);
        var __pytra_range_start_1 = 1L;
        var __pytra_range_stop_2 = 256L;
        var __pytra_range_step_3 = 1;
        if (__pytra_range_step_3 == 0) throw new Exception("range() arg 3 must not be zero");
        for (var i = __pytra_range_start_1; (__pytra_range_step_3 > 0) ? (i < __pytra_range_stop_2) : (i > __pytra_range_stop_2); i += __pytra_range_step_3)
        {
            var t = ((double)((i - 1L)) / (double)(254.0));
            var r = (long)((255.0 * ((((9.0 * (1.0 - t)) * t) * t) * t)));
            var g = (long)((255.0 * ((((15.0 * (1.0 - t)) * (1.0 - t)) * t) * t)));
            var b = (long)((255.0 * ((((8.5 * (1.0 - t)) * (1.0 - t)) * (1.0 - t)) * t)));
            Pytra.CsModule.py_runtime.py_set(palette, ((i * 3L) + 0L), r);
            Pytra.CsModule.py_runtime.py_set(palette, ((i * 3L) + 1L), g);
            Pytra.CsModule.py_runtime.py_set(palette, ((i * 3L) + 2L), b);
        }
        return Pytra.CsModule.py_runtime.py_bytes(palette);
    }

    public static List<byte> render_frame(long width, long height, double cr, double ci, long max_iter, long phase)
    {
        var frame = Pytra.CsModule.py_runtime.py_bytearray((width * height));
        long idx = 0L;
        var __pytra_range_start_4 = 0;
        var __pytra_range_stop_5 = height;
        var __pytra_range_step_6 = 1;
        if (__pytra_range_step_6 == 0) throw new Exception("range() arg 3 must not be zero");
        for (var y = __pytra_range_start_4; (__pytra_range_step_6 > 0) ? (y < __pytra_range_stop_5) : (y > __pytra_range_stop_5); y += __pytra_range_step_6)
        {
            var zy0 = ((-1.2) + (2.4 * ((double)(y) / (double)((height - 1L)))));
            var __pytra_range_start_7 = 0;
            var __pytra_range_stop_8 = width;
            var __pytra_range_step_9 = 1;
            if (__pytra_range_step_9 == 0) throw new Exception("range() arg 3 must not be zero");
            for (var x = __pytra_range_start_7; (__pytra_range_step_9 > 0) ? (x < __pytra_range_stop_8) : (x > __pytra_range_stop_8); x += __pytra_range_step_9)
            {
                var zx = ((-1.8) + (3.6 * ((double)(x) / (double)((width - 1L)))));
                var zy = zy0;
                long i = 0L;
                while (Pytra.CsModule.py_runtime.py_bool((i < max_iter)))
                {
                    var zx2 = (zx * zx);
                    var zy2 = (zy * zy);
                    if (Pytra.CsModule.py_runtime.py_bool(((zx2 + zy2) > 4.0)))
                    {
                        break;
                    }
                    zy = (((2.0 * zx) * zy) + ci);
                    zx = ((zx2 - zy2) + cr);
                    i = (i + 1L);
                }
                if (Pytra.CsModule.py_runtime.py_bool((i >= max_iter)))
                {
                    Pytra.CsModule.py_runtime.py_set(frame, idx, 0L);
                }
                else
                {
                    var color_index = (1L + (((long)Math.Floor(((i * 224L)) / (double)(max_iter)) + phase) % 255L));
                    Pytra.CsModule.py_runtime.py_set(frame, idx, color_index);
                }
                idx = (idx + 1L);
            }
        }
        return Pytra.CsModule.py_runtime.py_bytes(frame);
    }

    public static void run_06_julia_parameter_sweep()
    {
        long width = 320L;
        long height = 240L;
        long frames_n = 72L;
        long max_iter = 180L;
        string out_path = "sample/out/06_julia_parameter_sweep.gif";
        var start = Pytra.CsModule.time.perf_counter();
        List<List<byte>> frames = new List<List<byte>> {  };
        var center_cr = (-0.745);
        double center_ci = 0.186;
        double radius_cr = 0.12;
        double radius_ci = 0.1;
        var __pytra_range_start_10 = 0;
        var __pytra_range_stop_11 = frames_n;
        var __pytra_range_step_12 = 1;
        if (__pytra_range_step_12 == 0) throw new Exception("range() arg 3 must not be zero");
        for (var i = __pytra_range_start_10; (__pytra_range_step_12 > 0) ? (i < __pytra_range_stop_11) : (i > __pytra_range_stop_11); i += __pytra_range_step_12)
        {
            var t = ((double)(i) / (double)(frames_n));
            var angle = ((2.0 * Math.PI) * t);
            var cr = (center_cr + (radius_cr * Math.Cos(angle)));
            var ci = (center_ci + (radius_ci * Math.Sin(angle)));
            var phase = ((i * 5L) % 255L);
            Pytra.CsModule.py_runtime.py_append(frames, render_frame(width, height, cr, ci, max_iter, phase));
        }
        Pytra.CsModule.gif_helper.save_gif(out_path, width, height, frames, julia_palette(), delay_cs: 8L, loop: 0L);
        var elapsed = (Pytra.CsModule.time.perf_counter() - start);
        Pytra.CsModule.py_runtime.print("output:", out_path);
        Pytra.CsModule.py_runtime.print("frames:", frames_n);
        Pytra.CsModule.py_runtime.print("elapsed_sec:", elapsed);
    }

    public static void Main(string[] args)
    {
        run_06_julia_parameter_sweep();
    }
}
```
</details>

<details>
<summary>Rustã¸ã®å¤‰æ›ä¾‹ : 06_julia_parameter_sweep.rs</summary>

```rust
#[path = "../../src/rs_module/py_runtime.rs"]
mod py_runtime;
use py_runtime::{math_cos, math_exp, math_sin, math_sqrt, perf_counter, py_bool, py_grayscale_palette, py_in, py_isalpha, py_isdigit, py_len, py_print, py_save_gif, py_slice, py_write_rgb_png};

// ã“ã®ãƒ•ã‚¡ã‚¤ãƒ«ã¯è‡ªå‹•ç”Ÿæˆã§ã™ï¼ˆnative Rust modeï¼‰ã€‚

fn julia_palette() -> Vec<u8> {
    let mut palette = vec![0u8; (((256) * (3))) as usize];
    (palette)[0 as usize] = (0) as u8;
    (palette)[1 as usize] = (0) as u8;
    (palette)[2 as usize] = (0) as u8;
    for i in (1)..(256) {
        let mut t = ((( ((i) - (1)) ) as f64) / (( 254.0 ) as f64));
        let mut r = ((((255.0) * (((((((((9.0) * (((1.0) - (t))))) * (t))) * (t))) * (t))))) as i64);
        let mut g = ((((255.0) * (((((((((15.0) * (((1.0) - (t))))) * (((1.0) - (t))))) * (t))) * (t))))) as i64);
        let mut b = ((((255.0) * (((((((((8.5) * (((1.0) - (t))))) * (((1.0) - (t))))) * (((1.0) - (t))))) * (t))))) as i64);
        (palette)[((((i) * (3))) + (0)) as usize] = (r) as u8;
        (palette)[((((i) * (3))) + (1)) as usize] = (g) as u8;
        (palette)[((((i) * (3))) + (2)) as usize] = (b) as u8;
    }
    return (palette).clone();
}

fn render_frame(mut width: i64, mut height: i64, mut cr: f64, mut ci: f64, mut max_iter: i64, mut phase: i64) -> Vec<u8> {
    let mut frame = vec![0u8; (((width) * (height))) as usize];
    let mut idx = 0;
    for y in (0)..(height) {
        let mut zy0 = (((-1.2)) + (((2.4) * (((( y ) as f64) / (( ((height) - (1)) ) as f64))))));
        for x in (0)..(width) {
            let mut zx = (((-1.8)) + (((3.6) * (((( x ) as f64) / (( ((width) - (1)) ) as f64))))));
            let mut zy = zy0;
            let mut i = 0;
            while py_bool(&(((i) < (max_iter)))) {
                let mut zx2 = ((zx) * (zx));
                let mut zy2 = ((zy) * (zy));
                if py_bool(&(((((zx2) + (zy2))) > (4.0)))) {
                    break;
                }
                zy = ((((((2.0) * (zx))) * (zy))) + (ci));
                zx = ((((zx2) - (zy2))) + (cr));
                i = i + 1;
            }
            if py_bool(&(((i) >= (max_iter)))) {
                (frame)[idx as usize] = (0) as u8;
            } else {
                let mut color_index = ((1) + (((((((((i) * (224))) / (max_iter))) + (phase))) % (255))));
                (frame)[idx as usize] = (color_index) as u8;
            }
            idx = idx + 1;
        }
    }
    return (frame).clone();
}

fn run_06_julia_parameter_sweep() -> () {
    let mut width = 320;
    let mut height = 240;
    let mut frames_n = 72;
    let mut max_iter = 180;
    let mut out_path = "sample/out/06_julia_parameter_sweep.gif".to_string();
    let mut start = perf_counter();
    let mut frames: Vec<Vec<u8>> = vec![];
    let mut center_cr = (-0.745);
    let mut center_ci = 0.186;
    let mut radius_cr = 0.12;
    let mut radius_ci = 0.1;
    for i in (0)..(frames_n) {
        let mut t = ((( i ) as f64) / (( frames_n ) as f64));
        let mut angle = ((((2.0) * (std::f64::consts::PI))) * (t));
        let mut cr = ((center_cr) + (((radius_cr) * (math_cos(((angle) as f64))))));
        let mut ci = ((center_ci) + (((radius_ci) * (math_sin(((angle) as f64))))));
        let mut phase = ((((i) * (5))) % (255));
        frames.push(render_frame(width, height, cr, ci, max_iter, phase));
    }
    py_save_gif(&(out_path), width, height, &(frames), &(julia_palette()), 8, 0);
    let mut elapsed = ((perf_counter()) - (start));
    println!("{} {}", "output:".to_string(), out_path);
    println!("{} {}", "frames:".to_string(), frames_n);
    println!("{} {}", "elapsed_sec:".to_string(), elapsed);
}

fn main() {
    run_06_julia_parameter_sweep();
}
```
</details>


## ä½¿ã„æ–¹ã«ã¤ã„ã¦

å®Ÿéš›ã®ä½¿ã„æ–¹ã«ã¤ã„ã¦ã¯ [docs/how-to-use.md](docs/how-to-use.md) ã‚’ã”è¦§ãã ã•ã„ã€‚


## å®Ÿè£…æ¸ˆã¿ã®è¨€èªæ©Ÿèƒ½

- å¤‰æ•°ä»£å…¥ï¼ˆé€šå¸¸ä»£å…¥ã€å‹æ³¨é‡ˆä»˜ãä»£å…¥ã€æ‹¡å¼µä»£å…¥ã®ä¸»è¦ã‚±ãƒ¼ã‚¹ï¼‰
- ç®—è¡“æ¼”ç®—ï¼ˆ`+ - * / // % **` ã®ä¸»è¦ã‚±ãƒ¼ã‚¹ï¼‰
- æ¯”è¼ƒæ¼”ç®—ï¼ˆ`== != < <= > >= in not in is is not` ã®ä¸»è¦ã‚±ãƒ¼ã‚¹ï¼‰
- æ¡ä»¶åˆ†å²ï¼ˆ`if / elif / else`ï¼‰
- ãƒ«ãƒ¼ãƒ—ï¼ˆ`while`ã€`for in <iterable>`ã€`for in range(...)`ï¼‰
- ä¾‹å¤–ï¼ˆ`try/except/finally`ã€`raise` ã®ä¸»è¦ã‚±ãƒ¼ã‚¹ï¼‰
- é–¢æ•°å®šç¾©ãƒ»é–¢æ•°å‘¼ã³å‡ºã—ãƒ»æˆ»ã‚Šå€¤
- ã‚¯ãƒ©ã‚¹å®šç¾©ï¼ˆå˜ä¸€ç¶™æ‰¿ã€`__init__`ã€static memberã€instance memberï¼‰
- `@dataclass` ã®åŸºæœ¬å¤‰æ›
- æ–‡å­—åˆ—ï¼ˆf-string ã®ä¸»è¦ã‚±ãƒ¼ã‚¹ã€`replace` ãªã©ã®ä¸»è¦ãƒ¡ã‚½ãƒƒãƒ‰ï¼‰
- ã‚³ãƒ³ãƒ†ãƒŠï¼ˆ`list`, `dict`, `set`, `tuple` ã®ä¸»è¦ã‚±ãƒ¼ã‚¹ï¼‰
- list/set comprehension ã®ä¸»è¦ã‚±ãƒ¼ã‚¹
- `if __name__ == "__main__":` ã‚¬ãƒ¼ãƒ‰ã®èªè­˜
- å‹ãƒãƒƒãƒ”ãƒ³ã‚°ï¼ˆ`int`, `int8..uint64`, `float`, `float32`, `str`, `bool`, `None`ï¼‰
- for ï½ in , for ï½ in range()æ§‹æ–‡
- a[b:c] å½¢å¼ã®ã‚¹ãƒ©ã‚¤ã‚¹æ§‹æ–‡

## çµ„ã¿è¾¼ã¿é–¢æ•°

ã‹ãã‹ã‘

### module

- `math`ï¼ˆä¸»è¦é–¢æ•°: `sqrt`, `sin`, `cos`, `tan`, `exp`, `log`, `log10`, `floor`, `ceil`, `pow` ãªã©ï¼‰
- `time`ï¼ˆ`perf_counter`ï¼‰
- `pathlib`ï¼ˆåˆ©ç”¨ä¸­æ©Ÿèƒ½ã®ç¯„å›²ï¼‰
- `dataclasses`ï¼ˆ`@dataclass`ï¼‰
- `ast`ï¼ˆã‚»ãƒ«ãƒ•ãƒ›ã‚¹ãƒ†ã‚£ãƒ³ã‚°ã®ãŸã‚ã®ãƒ©ãƒ³ã‚¿ã‚¤ãƒ å®Ÿè£…ï¼‰

ç‹¬è‡ªè¿½åŠ ã€‚
- `py_module.png_helper` : PNGç”»åƒå‡ºåŠ›ãƒ˜ãƒ«ãƒ‘
- `py_module.gif_helper` : GIFç”»åƒå‡ºåŠ›ãƒ˜ãƒ«ãƒ‘

## ä½œæ¥­ä¸­

- C++, C#, Rustä»¥å¤–ã®è¨€èªã¸ã®ãƒˆãƒ©ãƒ³ã‚¹ãƒ‘ã‚¤ãƒ©æœ¬ä½“
- a[b:c] ä»¥å¤–ã®ã‚¹ãƒ©ã‚¤ã‚¹æ§‹æ–‡
- ãã®ä»–ã€è©³ã—ãã¯ã€[docs/todo.md](docs/todo.md) ã«æ›¸ã„ã¦ã¾ã™ã€‚

## æœªå®Ÿè£…é …ç›®

- æ¨™æº–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªç¶²ç¾…å¯¾å¿œï¼ˆ`import` å¯èƒ½ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®æ‹¡å……ï¼‰
- ä¾‹å¤–å‡¦ç†ãƒ»å‹æ¨è«–ã®é«˜åº¦åŒ–

## å¯¾å¿œäºˆå®šãªã—

- Python æ§‹æ–‡ã®å®Œå…¨äº’æ›ï¼ˆç¾çŠ¶ã¯ã‚µãƒ–ã‚»ãƒƒãƒˆï¼‰
- å‹•çš„ãªimport
- å‹•çš„ãªå‹ä»˜ã‘
- å¼±å‚ç…§, å¾ªç’°å‚ç…§ éå¯¾å¿œ
- ã‚¹ãƒ©ã‚¤ã‚¹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ


## é–‹ç™ºã«ã¤ã„ã¦

æœ¬ãƒˆãƒ©ãƒ³ã‚¹ãƒ‘ã‚¤ãƒ©ã¯ã€ä¸»ã«GPT-5.3-Codexã§é–‹ç™ºã—ã¦ã„ã¾ã™ã€‚

## ãƒ©ã‚¤ã‚»ãƒ³ã‚¹

MIT License
